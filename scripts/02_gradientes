# ============================================================
# Script_02: Gradientes espaciales (precio m² y densidad)
# ============================================================

# Config y paquetes
here::i_am("scripts/02_gradientes.R")
source(here::here("scripts", "00_Config.R"))

# Paths a procesados
fp_gpkg       <- here::here("data", "processed", "bogota_processed.gpkg")

# Definir CRS de trabajo

crs_wgs <- 4326
crs_bog <- 3116 ## MAGNA SIRGAS de Bogotá

# Cargar capas necesarias
upz                      <- st_read(fp_gpkg, layer = "upz",           quiet = TRUE)
manzanas                 <- st_read(fp_gpkg, layer = "manzanas",      quiet = TRUE)
propiedades              <- st_read(fp_gpkg, layer = "propiedades",   quiet = TRUE)
centro_internacional_ctr <- st_read(fp_gpkg, layer = "ci_centroid",   quiet = TRUE)

# --- Generar variables para la estimación ---

props <- propiedades %>%
  mutate(
    dist_ci_km = as.numeric(st_distance(., centro_internacional_ctr))/ 1000,
    ln_st = log(surface_total),
    ln_sc = log(pmax(1, surface_covered))
  ) %>%
  # pega UPZ 
  st_transform(4326) %>%
  st_join(st_transform(upz, 4326) %>% dplyr::select(cod_upz), join = st_within, left = TRUE) %>%
  st_transform(crs_bog) %>%
  filter(!is.na(cod_upz)) %>%
  mutate(cod_upz = factor(cod_upz))

# Data frames separados
sale  <- props %>% filter(operation == "Venta")
rent  <- props %>% filter(operation == "Alquiler")


# -----------------------------------------------------------------
# Gradiente Precio distancia
# -----------------------------------------------------------------

  ### Primero estimamos asumiendo la forma de la relación entre la distancia y el precio (lineal)

# --- VENTAS ---

m_sale <- gam(
  log(price_m2) ~
    dist_ci_km +                     # gradiente vs distancia
    ln_st + ln_sc +                  # tamaños
    bedrooms + bathrooms + rooms +   # controles
    s(cod_upz, bs = "re"),           # efecto aleatorio UPZ
  data = sale, method = "REML"
)

# --- ALQUILER ---
m_rent <- gam(
  log(price_m2) ~
    dist_ci_km+
    ln_st+ ln_sc +
    bedrooms + bathrooms + rooms +   
    s(cod_upz, bs = "re"),
  data = rent, method = "REML"
)

summary(m_sale)
summary(m_rent)


  ### Luego damos espacio para no linealidades en la relación entre precio y distancia

# --- VENTAS ---

m_sale <- gam(
  log(price_m2) ~
    s(dist_ci_km, k = 5) +           # gradiente (curva) vs distancia
    ln_st + ln_sc +                  # tamaños
    bedrooms + bathrooms + rooms +   # lineales
    s(cod_upz, bs = "re"),           # efecto aleatorio UPZ
  data = sale, method = "REML"
)

# --- ALQUILER ---
m_rent <- gam(
  log(price_m2) ~
    s(dist_ci_km, k = 5) +
    ln_st + ln_sc +                  # tamaños
    bedrooms + bathrooms + rooms +   # lineales
    s(cod_upz, bs = "re"),
  data = rent, method = "REML"
)


summary(m_sale)
summary(m_rent)

gam.check(m_sale)  # chequeo de k
gam.check(m_rent)

  ### Ahora estimamos por medio de efectos fijos por UPZ

# VENTA
m_sale_fe <- feols(
  log(price_m2) ~ dist_ci_km + log(surface_total) + log(pmax(1, surface_covered)) +
    bedrooms + bathrooms + rooms | cod_upz,
  data = sale,
)

# ALQUILER
m_rent_fe <- feols(
  log(price_m2) ~ dist_ci_km + log(surface_total) + log(pmax(1, surface_covered)) +
    bedrooms + bathrooms + rooms | cod_upz,
  data = rent,
)

etable(m_sale_fe, m_rent_fe)


# Gráficos de gradientes

pred_curve <- function(modelo, df, by = 0.25) {
  dmax <- ceiling(max(df$dist_ci_km, na.rm = TRUE))
  newd <- data.frame(
    dist_ci_km = seq(0, dmax, by = by),
    ln_st = median(df$ln_st, na.rm = TRUE),
    ln_sc = median(df$ln_sc, na.rm = TRUE),
    bedrooms = round(median(df$bedrooms, na.rm = TRUE)),
    bathrooms = round(median(df$bathrooms, na.rm = TRUE)),
    rooms = round(median(df$rooms, na.rm = TRUE)),
    cod_upz = levels(df$cod_upz)[1]
  )
  pr <- predict(modelo, newd, se.fit = TRUE)
  newd$fit  <- pr$fit
  newd$se   <- pr$se.fit
  newd$yhat <- exp(newd$fit)
  newd$lwr  <- exp(newd$fit - 1.96*newd$se)
  newd$upr  <- exp(newd$fit + 1.96*newd$se)
  newd
}

curve_sale <- pred_curve(m_sale, sale) %>% mutate(market = "Venta")
curve_rent <- pred_curve(m_rent, rent) %>% mutate(market = "Alquiler")
curves <- bind_rows(curve_sale, curve_rent)
curves_fac <- curves %>%
  mutate(market = factor(market,
                         levels = c("Venta","Alquiler"),
                         labels = c("Venta","Alquiler")))

ggplot(curves_fac, aes(dist_ci_km, yhat)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = .15, fill = "grey70", color = NA) +
  geom_line(size = 1) +
  facet_wrap(~ market, ncol = 2, scales = "free_y") +
  labs(
    x = "Distancia al CI (km)",
    y = "Precio predicho (COP)",
    title = "Gradiente estimado vs distancia (paneles por mercado)"
  ) +
  theme_minimal() +
  theme(strip.text = element_text(face = "bold"))


# -----------------------------------------------------------------
# Gradiente Densidad poblacional distancia
# -----------------------------------------------------------------


mzn <- st_transform(manzanas, crs_wgs) %>%
  mutate(
    dist_ci_km = as.numeric(st_distance(., centro_internacional_ctr)) / 1000
  )

# pega UPZ (join espacial) para FE/RE
mzn_w_upz <- mzn %>%
  st_transform(crs_wgs) %>%
  st_join(st_transform(upz, crs_wgs) %>% dplyr::select(cod_upz),
          join = st_within, left = TRUE) %>%
  filter(!is.na(cod_upz)) %>%
  mutate(
    cod_upz = factor(cod_upz),
    # log-densidad (evita log(0))
    ln_dens = log(pmax(1, densidad_hab_km2))
  )

df_den <- st_drop_geometry(mzn_w_upz) %>%
  filter(is.finite(dist_ci_km), is.finite(ln_dens))

# Modelo lineal
m_den_lin <- gam(
  ln_dens ~ dist_ci_km + s(cod_upz, bs = "re") + s(area_km2, k=4),
  data = df_den, method = "REML"
)

# Modelo no lineal
m_den_gam <- gam(ln_dens ~ s(dist_ci_km, k=5) + s(area_km2, k=4) + s(cod_upz, bs="re"),
                 data = df_den, method = "REML")

summary(m_den_lin)
summary(m_den_gam)
gam.check(m_den_gam)  # chequeo de k




# Curva predicha con IC 95%
pred_curve_den <- function(modelo, df, by = 0.25) {
  dmax <- ceiling(max(df$dist_ci_km, na.rm = TRUE))
  newd <- data.frame(
    dist_ci_km = seq(0, dmax, by = by),
    area_km2 = median(df$area_km2, na.rm = TRUE),
    cod_upz = levels(df$cod_upz)[1]   # efecto aleatorio en nivel de referencia
  )
  pr <- predict(modelo, newdata = newd, se.fit = TRUE)
  newd$fit  <- pr$fit
  newd$se   <- pr$se.fit
  newd$yhat <- exp(newd$fit)                      # volver a hab/km²
  newd$lwr  <- exp(newd$fit - 1.96 * newd$se)
  newd$upr  <- exp(newd$fit + 1.96 * newd$se)
  newd
}

curve_den_lin <- pred_curve_den(m_den_lin, df_den) %>% mutate(modelo = "Lineal")
curve_den_gam <- pred_curve_den(m_den_gam, df_den) %>% mutate(modelo = "GAM (suavizado)")

curves_den <- bind_rows(curve_den_lin, curve_den_gam)

# Gráfico del gradiente de densidad
ggplot(curves_den, aes(dist_ci_km, yhat, color = modelo, fill = modelo)) +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = .15, color = NA) +
  geom_line(size = 1) +
  scale_y_continuous(labels = scales::comma_format()) +
  labs(
    x = "Distancia al CI (km)",
    y = "Densidad poblacional predicha (hab/km²)",
    title = "Gradiente estimado de densidad poblacional vs distancia",
    color = "Modelo", fill = "Modelo",
    caption = "Modelos: ln(densidad) ~ dist | ln(densidad) ~ s(dist); ambos con RE(UPZ)"
  ) +
  theme_minimal() +
  theme(legend.position = "top")

# Alternativa OLS con FE por UPZ
m_den_fe <- feols(
  ln_dens ~ dist_ci_km + area_km2 | cod_upz,
  data = df_den,
  cluster = ~ cod_upz
)


etable(m_den_fe)



